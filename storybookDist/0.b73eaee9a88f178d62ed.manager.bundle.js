(window.webpackJsonp = window.webpackJsonp || []).push([[0], {
  457(module, __webpack_exports__, __webpack_require__) {
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, 'WithTooltipPure', (() => WithTooltip_WithTooltipPure)), __webpack_require__.d(__webpack_exports__, 'WithToolTipState', (() => WithTooltip_WithToolTipState)), __webpack_require__.d(__webpack_exports__, 'WithTooltip', (() => WithTooltip_WithToolTipState)); __webpack_require__(16), __webpack_require__(50), __webpack_require__(23), __webpack_require__(4), __webpack_require__(15), __webpack_require__(9), __webpack_require__(5), __webpack_require__(13), __webpack_require__(7), __webpack_require__(10), __webpack_require__(14), __webpack_require__(17), __webpack_require__(6), __webpack_require__(38); const react = __webpack_require__(0); const react_default = __webpack_require__.n(react); const esm = __webpack_require__(1); const global_window = __webpack_require__(8); const window_default = __webpack_require__.n(global_window); const react_popper_tooltip = __webpack_require__(939); const memoizerific = (__webpack_require__(77), __webpack_require__(26), __webpack_require__(168), __webpack_require__(18), __webpack_require__(28)); const memoizerific_default = __webpack_require__.n(memoizerific); const utils = __webpack_require__(100); function _extends() { return (_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source)Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]); } return target; }).apply(this, arguments); } function _objectWithoutProperties(source, excluded) { if (source == null) return {}; let key; let i; const target = (function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; let key; let i; const target = {}; const sourceKeys = Object.keys(source); for (i = 0; i < sourceKeys.length; i++)key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]); return target; }(source, excluded)); if (Object.getOwnPropertySymbols) { const sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++)key = sourceSymbolKeys[i], excluded.indexOf(key) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]); } return target; } let _templateObject; let _templateObject2; const match = memoizerific_default()(1e3)((function (requests, actual, value) { const fallback = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; return actual.split('-')[0] === requests ? value : fallback; })); const Arrow = esm.styled.div({ position: 'absolute', borderStyle: 'solid' }, ((_ref) => {
      const { placement } = _ref; let x = 0; let
        y = 0; switch (!0) { case placement.startsWith('left') || placement.startsWith('right'): y = 8; break; case placement.startsWith('top') || placement.startsWith('bottom'): x = 8; } return { transform: 'translate3d('.concat(x, 'px, ').concat(y, 'px, 0px)') };
    }), ((_ref2) => {
      const { theme } = _ref2; const { color } = _ref2; const
        { placement } = _ref2; return {
        bottom: ''.concat(match('top', placement, -8, 'auto'), 'px'), top: ''.concat(match('bottom', placement, -8, 'auto'), 'px'), right: ''.concat(match('left', placement, -8, 'auto'), 'px'), left: ''.concat(match('right', placement, -8, 'auto'), 'px'), borderBottomWidth: ''.concat(match('top', placement, '0', 8), 'px'), borderTopWidth: ''.concat(match('bottom', placement, '0', 8), 'px'), borderRightWidth: ''.concat(match('left', placement, '0', 8), 'px'), borderLeftWidth: ''.concat(match('right', placement, '0', 8), 'px'), borderTopColor: match('top', placement, theme.color[color] || color || theme.base === 'light' ? Object(utils.c)(theme.background.app) : Object(utils.a)(theme.background.app), 'transparent'), borderBottomColor: match('bottom', placement, theme.color[color] || color || theme.base === 'light' ? Object(utils.c)(theme.background.app) : Object(utils.a)(theme.background.app), 'transparent'), borderLeftColor: match('left', placement, theme.color[color] || color || theme.base === 'light' ? Object(utils.c)(theme.background.app) : Object(utils.a)(theme.background.app), 'transparent'), borderRightColor: match('right', placement, theme.color[color] || color || theme.base === 'light' ? Object(utils.c)(theme.background.app) : Object(utils.a)(theme.background.app), 'transparent'),
      };
    })); const Wrapper = esm.styled.div(((_ref3) => ({ display: _ref3.hidden ? 'none' : 'inline-block', zIndex: 2147483647 })), ((_ref4) => {
      const { theme } = _ref4; const
        { color } = _ref4; return _ref4.hasChrome ? {
        background: theme.color[color] || color || theme.base === 'light' ? Object(utils.c)(theme.background.app) : Object(utils.a)(theme.background.app), filter: '\n            drop-shadow(0px 5px 5px rgba(0,0,0,0.05))\n            drop-shadow(0 1px 3px rgba(0,0,0,0.1))\n          ', borderRadius: 2 * theme.appBorderRadius, fontSize: theme.typography.size.s1,
      } : {};
    })); const Tooltip_Tooltip = function Tooltip(_ref5) {
      const { placement } = _ref5; const { hasChrome } = _ref5; const { children } = _ref5; const { arrowProps } = _ref5; const { tooltipRef } = _ref5; const { arrowRef } = _ref5; const { color } = _ref5; const
        props = _objectWithoutProperties(_ref5, ['placement', 'hasChrome', 'children', 'arrowProps', 'tooltipRef', 'arrowRef', 'color']); return react_default.a.createElement(Wrapper, {
        hasChrome, placement, ref: tooltipRef, ...props, color,
      }, hasChrome && react_default.a.createElement(Arrow, {
        placement, ref: arrowRef, ...arrowProps, color,
      }), children);
    }; function _slicedToArray(arr, i) { return (function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }(arr)) || (function _iterableToArrayLimit(arr, i) { if (typeof Symbol === 'undefined' || !(Symbol.iterator in Object(arr))) return; const _arr = []; let _n = !0; let _d = !1; let _e = void 0; try { for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i || _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { _n || _i.return == null || _i.return(); } finally { if (_d) throw _e; } } return _arr; }(arr, i)) || (function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === 'string') return _arrayLikeToArray(o, minLen); let n = Object.prototype.toString.call(o).slice(8, -1); n === 'Object' && o.constructor && (n = o.constructor.name); if (n === 'Map' || n === 'Set') return Array.from(o); if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }(arr, i)) || (function _nonIterableRest() { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function _arrayLikeToArray(arr, len) { (len == null || len > arr.length) && (len = arr.length); for (var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i]; return arr2; } function WithTooltip_extends() { return (WithTooltip_extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source)Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]); } return target; }).apply(this, arguments); } function WithTooltip_objectWithoutProperties(source, excluded) { if (source == null) return {}; let key; let i; const target = (function WithTooltip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; let key; let i; const target = {}; const sourceKeys = Object.keys(source); for (i = 0; i < sourceKeys.length; i++)key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]); return target; }(source, excluded)); if (Object.getOwnPropertySymbols) { const sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++)key = sourceSymbolKeys[i], excluded.indexOf(key) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]); } return target; } function _taggedTemplateLiteral(strings, raw) { return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }Tooltip_Tooltip.displayName = 'Tooltip', Tooltip_Tooltip.defaultProps = {
      color: void 0, arrowRef: void 0, tooltipRef: void 0, hasChrome: !0, placement: 'top', arrowProps: {},
    }; const WithTooltip_document = window_default.a.document; const TargetContainer = esm.styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral(['\n  display: inline-block;\n  cursor: ', ';\n'])), ((props) => (props.mode === 'hover' ? 'default' : 'pointer'))); const TargetSvgContainer = esm.styled.g(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(['\n  cursor: ', ';\n'])), ((props) => (props.mode === 'hover' ? 'default' : 'pointer'))); var WithTooltip_WithTooltipPure = function WithTooltipPure(_ref) {
      const { svg } = _ref; const { trigger } = _ref; const placement = (_ref.closeOnClick, _ref.placement); const { modifiers } = _ref; const { hasChrome } = _ref; const _tooltip = _ref.tooltip; const { children } = _ref; const { tooltipShown } = _ref; const { onVisibilityChange } = _ref; const props = WithTooltip_objectWithoutProperties(_ref, ['svg', 'trigger', 'closeOnClick', 'placement', 'modifiers', 'hasChrome', 'tooltip', 'children', 'tooltipShown', 'onVisibilityChange']); const
        Container = svg ? TargetSvgContainer : TargetContainer; return react_default.a.createElement(react_popper_tooltip.a, {
        placement,
        trigger,
        modifiers,
        tooltipShown,
        onVisibilityChange,
        tooltip: function tooltip(_ref2) {
          const { getTooltipProps } = _ref2; const { getArrowProps } = _ref2; const { tooltipRef } = _ref2; const { arrowRef } = _ref2; const
            tooltipPlacement = _ref2.placement; return react_default.a.createElement(Tooltip_Tooltip, {
            hasChrome, placement: tooltipPlacement, tooltipRef, arrowRef, arrowProps: getArrowProps(), ...getTooltipProps(),
          }, typeof _tooltip === 'function' ? _tooltip({ onHide: function onHide() { return onVisibilityChange(!1); } }) : _tooltip);
        },
      }, ((_ref3) => {
        const { getTriggerProps } = _ref3; const
          { triggerRef } = _ref3; return react_default.a.createElement(Container, { ref: triggerRef, ...getTriggerProps(), ...props }, children);
      }));
    }; WithTooltip_WithTooltipPure.displayName = 'WithTooltipPure', WithTooltip_WithTooltipPure.defaultProps = {
      svg: !1, trigger: 'hover', closeOnClick: !1, placement: 'top', modifiers: [{ name: 'preventOverflow', options: { padding: 8 } }, { name: 'offset', options: { offset: [8, 8] } }, { name: 'arrow', options: { padding: 8 } }], hasChrome: !0, tooltipShown: !1,
    }; var WithTooltip_WithToolTipState = function WithToolTipState(_ref4) {
      const { startOpen } = _ref4; const onChange = _ref4.onVisibilityChange; const rest = WithTooltip_objectWithoutProperties(_ref4, ['startOpen', 'onVisibilityChange']); const _useState2 = _slicedToArray(Object(react.useState)(startOpen || !1), 2); const tooltipShown = _useState2[0]; const setTooltipShown = _useState2[1]; const
        onVisibilityChange = Object(react.useCallback)(((visibility) => { onChange && !1 === onChange(visibility) || setTooltipShown(visibility); }), [onChange]); return Object(react.useEffect)((() => { const hide = function hide() { return onVisibilityChange(!1); }; WithTooltip_document.addEventListener('keydown', hide, !1); const iframes = Array.from(WithTooltip_document.getElementsByTagName('iframe')); const unbinders = []; return iframes.forEach(((iframe) => { const bind = function bind() { try { iframe.contentWindow.document && (iframe.contentWindow.document.addEventListener('click', hide), unbinders.push((() => { try { iframe.contentWindow.document.removeEventListener('click', hide); } catch (e) {} }))); } catch (e) {} }; bind(), iframe.addEventListener('load', bind), unbinders.push((() => { iframe.removeEventListener('load', bind); })); })), function () { WithTooltip_document.removeEventListener('keydown', hide), unbinders.forEach(((unbind) => { unbind(); })); }; })), react_default.a.createElement(WithTooltip_WithTooltipPure, { ...rest, tooltipShown, onVisibilityChange });
    }; WithTooltip_WithToolTipState.displayName = 'WithToolTipState';
  },
}]);
